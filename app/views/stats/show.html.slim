- content_for :title, "Statistics"

- content_for :sidebar do
  .stats-sidebar
    details.stats-sidebar-section open=true
      summary.stats-sidebar-summary Settings
      .stats-controls
        label
          span.label-text Granularity
          select#stats-granularity
            option value="day" Day
            option value="week" Week
            option value="month" selected=true Month
        label
          span.label-text Retention granularity
          select#stats-retention-granularity
            option value="month" Monthly
            option value="quarter" selected=true Quarterly
        label
          span.label-text Retention cohort
          select#stats-retention-segment
            option value="all" selected=true All new users
        option value="replied_to_others" New participants who replied to others
        label
          span.label-text Range
          select#stats-range
            option value="last_30" Last 30 days
            option value="last_90" Last 90 days
            option value="last_365" Last 365 days
            option value="last_3650" Last 10 years
            option value="after_2000" selected=true After 2000
            option value="all_time" All time
            option value="custom" Custom range
        label.stats-custom-range hidden=true
          span.label-text From
          input#stats-from type="date"
        label.stats-custom-range hidden=true
          span.label-text To
          input#stats-to type="date"
        button#stats-apply-range.button-secondary type="button" Apply
    details.stats-sidebar-section open=true
      summary.stats-sidebar-summary Graphs
      .stats-toc
        ul
          li = link_to "Activity overview", "#stats-chart-main"
          li = link_to "Messages", "#stats-chart-message-breakdown"
          li = link_to "New topics by attachments/commitfest status", "#stats-chart-attachments"
          li = link_to "New topics by user tenure and attachments", "#stats-chart-new-topic-attachments"
          li = link_to "Per topic activity within interval", "#stats-chart-depth"
          li = link_to "Topic length", "#stats-chart-created-depth"
          li = link_to "Topic longevity", "#stats-chart-longevity"
          li = link_to "Topic longevity heatmap", "#stats-chart-longevity-heatmap"
          li = link_to "Participant lifetime", "#stats-chart-participant-lifetime"
          li = link_to "New participant daily message rate", "#stats-chart-new-participant-rate"
          li = link_to "New vs retained participants", "#stats-chart-participant-retention"
          li = link_to "Retention milestones", "#stats-chart-retention-milestones"
          li = link_to "Participant retention heatmap", "#stats-chart-retention-heatmap"
          li = link_to "Participant activity intensity heatmap", "#stats-chart-retention-intensity-heatmap"

.stats-page
  h1 Statistics
  p.stats-intro A public overview of Hackorum activity over time.

  - main_series = []
  - main_series << { key: "participants_active", label: "Active participants" }
  - main_series << { key: "participants_new", label: "New participants" }
  - main_series << { key: "retained_365_participants", label: "Retained participants (365d+)" }
  - main_series << { key: "new_users_replied_to_others", label: "New participants replying to others" }
  - main_series << { key: "topics_new", label: "New topics", checked: true }
  - main_series << { key: "topics_new_by_new_users", label: "New topics by new users" }
  - main_series << { key: "topics_new_with_attachments_by_new_users", label: "New topics with attachments by new users" }
  - main_series << { key: "topics_active", label: "Active topics", checked: true }
  - main_series << { key: "messages_total", label: "Total messages" }
  - main_series << { key: "messages_committers", label: "Messages by committers" }
  - main_series << { key: "messages_contributors", label: "Messages by contributors" }
  - main_series << { key: "messages_new_participants", label: "Messages by new participants" }
  - main_series << { key: "topics_new_with_contributor_activity", label: "New topics with contributor activity" }
  - main_series << { key: "topics_new_without_contributor_activity", label: "New topics without contributor activity" }
  - main_series << { key: "topics_messages_avg", label: "Active topic avg msgs", checked: false }
  - main_series << { key: "topics_messages_median", label: "Active topic median msgs", checked: false }
  - main_series << { key: "topics_messages_max", label: "Active topic max msgs", checked: false }
  - main_series << { key: "topics_created_messages_avg", label: "New topic avg msgs", checked: false }
  - main_series << { key: "topics_created_messages_median", label: "New topic median msgs", checked: false }
  - main_series << { key: "topics_created_messages_max", label: "New topic max msgs", checked: false }
  - main_series << { key: "topic_longevity_avg_days", label: "Topic longevity avg days", checked: false }
  - main_series << { key: "topic_longevity_median_days", label: "Topic longevity median days", checked: false }
  - main_series << { key: "topic_longevity_max_days", label: "Topic longevity max days", checked: false }
  - main_series << { key: "new_participants_lifetime_avg_days", label: "New participant lifetime avg days", checked: false }
  - main_series << { key: "new_participants_lifetime_median_days", label: "New participant lifetime median days", checked: false }
  - main_series << { key: "new_participants_lifetime_max_days", label: "New participant lifetime max days", checked: false }
  - main_series << { key: "retained_365_lifetime_avg_days", label: "Retained lifetime avg days", checked: false }
  - main_series << { key: "retained_365_lifetime_median_days", label: "Retained lifetime median days", checked: false }
  - main_series << { key: "new_participants_daily_avg_messages", label: "New participant daily avg msgs", checked: false }
  - main_series << { key: "retained_365_daily_avg_messages", label: "Retained daily avg msgs", checked: false }
  - depth_series = []
  - depth_series << { key: "topics_messages_avg", label: "Avg messages", checked: true }
  - depth_series << { key: "topics_messages_median", label: "Median messages", checked: true }
  - depth_series << { key: "topics_messages_max", label: "Max messages", checked: true }
  - created_depth_series = []
  - created_depth_series << { key: "topics_created_messages_avg", label: "Avg messages", checked: true }
  - created_depth_series << { key: "topics_created_messages_median", label: "Median messages", checked: true }
  - created_depth_series << { key: "topics_created_messages_max", label: "Max messages", checked: true }
  - longevity_series = []
  - longevity_series << { key: "topic_longevity_avg_days", label: "Avg days", checked: true }
  - longevity_series << { key: "topic_longevity_median_days", label: "Median days", checked: true }
  - longevity_series << { key: "topic_longevity_max_days", label: "Max days", checked: true }
  - participant_lifetime_series = []
  - participant_lifetime_series << { key: "new_participants_lifetime_avg_days", label: "New avg days", checked: true }
  - participant_lifetime_series << { key: "new_participants_lifetime_median_days", label: "New median days", checked: true }
  - participant_lifetime_series << { key: "new_participants_lifetime_max_days", label: "New max days", checked: true }
  - participant_lifetime_series << { key: "retained_365_lifetime_avg_days", label: "Retained avg days", checked: true }
  - participant_lifetime_series << { key: "retained_365_lifetime_median_days", label: "Retained median days", checked: true }
  - new_participant_rate_series = []
  - new_participant_rate_series << { key: "new_participants_daily_avg_messages", label: "New participants", checked: true }
  - new_participant_rate_series << { key: "retained_365_daily_avg_messages", label: "Retained 365d+", checked: true }
  - participant_retention_series = []
  - participant_retention_series << { key: "retained_365_participants", label: "Retained 365d+", checked: true }
  - participant_retention_series << { key: "participants_new_not_retained_365", label: "New (not retained)", checked: true }
  - retention_milestone_series = []
  - retention_milestone_series << { key: "retention_q1", label: "3m+", checked: true }
  - retention_milestone_series << { key: "retention_q2", label: "6m+", checked: true }
  - retention_milestone_series << { key: "retention_q4", label: "1y+", checked: true }
  - retention_milestone_series << { key: "retention_q6", label: "1.5y+", checked: false }
  - retention_milestone_series << { key: "retention_q8", label: "2y+", checked: false }
  - retention_milestone_series << { key: "retention_q10", label: "2.5y+", checked: false }
  - retention_milestone_series << { key: "retention_q12", label: "3y+", checked: false }
  - retention_milestone_series << { key: "retention_q16", label: "4y+", checked: false }
  - retention_milestone_series << { key: "retention_q20", label: "5y+", checked: false }
  - message_breakdown_series = []
  - message_breakdown_series << { key: "messages_committers", label: "Committers", checked: true }
  - message_breakdown_series << { key: "messages_contributors_non_committers", label: "Contributors (non-committers)", checked: true }
  - message_breakdown_series << { key: "messages_new_participants", label: "New participants", checked: true }
  - message_breakdown_series << { key: "messages_regular_participants", label: "Regular participants", checked: true }
  - attachment_series = []
  - attachment_series << { key: "topics_new_no_attachments", label: "No attachments", checked: true }
  - attachment_series << { key: "topics_new_with_attachments_no_commitfest", label: "Attachment, not commitfest", checked: true }
  - attachment_series << { key: "topics_new_commitfest_in_progress", label: "Commitfest in progress", checked: true }
  - attachment_series << { key: "topics_new_commitfest_abandoned", label: "Commitfest rejected", checked: true }
  - attachment_series << { key: "topics_new_commitfest_committed", label: "Commitfest committed", checked: true }
  - new_topic_attachment_series = []
  - new_topic_attachment_series << { key: "topics_new_by_new_users_no_attachments", label: "New users, no attachments", checked: true }
  - new_topic_attachment_series << { key: "topics_new_by_new_users_with_attachments", label: "New users, attachments", checked: true }
  - new_topic_attachment_series << { key: "topics_new_by_existing_users_no_attachments", label: "Existing users, no attachments", checked: true }
  - new_topic_attachment_series << { key: "topics_new_by_existing_users_with_attachments", label: "Existing users, attachments", checked: true }

  .stats-charts
    = render "chart_block",
      title: "Activity overview",
      chart_key: "main",
      chart_dom_id: "stats-chart-main",
      editor_id: "stats-editor-main",
      apply_id: "stats-editor-apply-main",
      series: main_series

    = render "chart_block",
      title: "Messages",
      chart_key: "message_breakdown",
      chart_dom_id: "stats-chart-message-breakdown",
      editor_id: "stats-editor-message-breakdown",
      apply_id: "stats-editor-apply-message-breakdown",
      series: message_breakdown_series

    = render "chart_block",
      title: "New topics by attachment/commitfest status",
      chart_key: "attachments",
      chart_dom_id: "stats-chart-attachments",
      editor_id: "stats-editor-attachments",
      apply_id: "stats-editor-apply-attachments",
      series: attachment_series

    = render "chart_block",
      title: "New topics by user tenure and attachments",
      chart_key: "new_topic_attachments",
      chart_dom_id: "stats-chart-new-topic-attachments",
      editor_id: "stats-editor-new-topic-attachments",
      apply_id: "stats-editor-apply-new-topic-attachments",
      series: new_topic_attachment_series

    = render "chart_block",
      title: "Per topic activity within interval",
      chart_key: "depth",
      chart_dom_id: "stats-chart-depth",
      editor_id: "stats-editor-depth",
      apply_id: "stats-editor-apply-depth",
      series: depth_series

    = render "chart_block",
      title: "Topic length (topic created within interval, replies possibly later)",
      chart_key: "created_depth",
      chart_dom_id: "stats-chart-created-depth",
      editor_id: "stats-editor-created-depth",
      apply_id: "stats-editor-apply-created-depth",
      series: created_depth_series

    = render "chart_block",
      title: "Topic longevity (topic created within interval, replies possibly later)",
      chart_key: "longevity",
      chart_dom_id: "stats-chart-longevity",
      editor_id: "stats-editor-longevity",
      apply_id: "stats-editor-apply-longevity",
      series: longevity_series

    details.stats-chart-block data-collapsible="longevity_heatmap" open=true
      summary.stats-chart-summary
        h2 Topic longevity heatmap
      .stats-chart-body
        #stats-chart-longevity-heatmap

    = render "chart_block",
      title: "Participant lifetime (first to last message)",
      chart_key: "participant_lifetime",
      chart_dom_id: "stats-chart-participant-lifetime",
      editor_id: "stats-editor-participant-lifetime",
      apply_id: "stats-editor-apply-participant-lifetime",
      series: participant_lifetime_series

    = render "chart_block",
      title: "New participant daily message rate",
      chart_key: "new_participant_rate",
      chart_dom_id: "stats-chart-new-participant-rate",
      editor_id: "stats-editor-new-participant-rate",
      apply_id: "stats-editor-apply-new-participant-rate",
      series: new_participant_rate_series

    = render "chart_block",
      title: "New vs retained participants",
      chart_key: "participant_retention",
      chart_dom_id: "stats-chart-participant-retention",
      editor_id: "stats-editor-participant-retention",
      apply_id: "stats-editor-apply-participant-retention",
      series: participant_retention_series

    = render "chart_block",
      title: "Retention milestones (cumulative)",
      chart_key: "retention_milestones",
      chart_dom_id: "stats-chart-retention-milestones",
      editor_id: "stats-editor-retention-milestones",
      apply_id: "stats-editor-apply-retention-milestones",
      series: retention_milestone_series

    details.stats-chart-block data-collapsible="retention_heatmap" open=true
      summary.stats-chart-summary
        h2 Participant retention heatmap
      .stats-chart-body
        p.stats-heatmap-note Y-axis: cohort start month. X-axis: months since first message.
        #stats-chart-retention-heatmap

    details.stats-chart-block data-collapsible="retention_intensity" open=true
      summary.stats-chart-summary
        h2 Participant activity intensity heatmap
      .stats-chart-body
        p.stats-heatmap-note Y-axis: cohort start month. X-axis: months since first message.
        #stats-chart-retention-intensity-heatmap

  details.stats-explainer
    summary Metric definitions
    .stats-explainer-body
      p
        strong Active participants:
        |  People who posted at least once in the selected interval.
      p
        strong New participants:
        |  People whose first-ever message is in the selected interval.
      p
        strong New topics:
        |  Topics created in the selected interval.
      p
        strong Active topics:
        |  Topics with at least one message in the selected interval.
      p
        strong New topics with contributor activity:
        |  Topics created in the interval that have ever received a contributor reply.
      p
        strong New topics without contributor activity:
        |  Topics created in the interval that have never received a contributor reply.
      p
        strong Message roles:
        |  Messages grouped by contributor role and new participant status. Contributor totals exclude committers; regular participants exclude contributors and new participants.
      p
        strong Active contributors and committers:
        |  People with contributor memberships who posted during the interval, split by contributor or committer membership.
      p
        strong New participant lifetime:
        |  Average, median, and maximum time between the first and last message for participants whose first message is in the interval.
      p
        strong New participant daily message rate:
        |  Average of each new participant's total messages to date divided by days since their first message, measured as of today.
      p
        strong Retained participants (365d+):
        |  New participants who posted at least once 365 days after their first message.
      p
        strong Retained participant lifetime:
        |  Average and median lifetime for retained participants (first to last message).
      p
        strong Retained participant daily message rate:
        |  Average of each retained participant's total messages to date divided by days since their first message, measured as of today.
      p
        strong Participant retention heatmap:
        |  Monthly cohorts on the y-axis, months since first message on the x-axis, and the share of the cohort active in that month.
      p
        strong Participant activity intensity heatmap:
        |  Monthly cohorts on the y-axis, months since first message on the x-axis, and average messages per active participant in that month.
      p
        strong Topic depth:
        |  Average, median, and maximum messages per active topic in the interval.
      p
        strong New topic depth:
        |  Average, median, and maximum messages per topic created in the interval (including future replies).
      p
        strong Topic longevity:
        |  Average, median, and maximum age of active topics (first to last message).

  script[src="https://cdn.jsdelivr.net/npm/vega@5.25.0"]
  script[src="https://cdn.jsdelivr.net/npm/vega-embed@6.22.2"]
  script
    |
      (function() {
        const mainEl = document.getElementById("stats-chart-main");
        const depthEl = document.getElementById("stats-chart-depth");
        const createdDepthEl = document.getElementById("stats-chart-created-depth");
        const messageBreakdownEl = document.getElementById("stats-chart-message-breakdown");
        const attachmentsEl = document.getElementById("stats-chart-attachments");
        const newTopicAttachmentsEl = document.getElementById("stats-chart-new-topic-attachments");
        const longevityEl = document.getElementById("stats-chart-longevity");
        const participantLifetimeEl = document.getElementById("stats-chart-participant-lifetime");
        const newParticipantRateEl = document.getElementById("stats-chart-new-participant-rate");
        const participantRetentionEl = document.getElementById("stats-chart-participant-retention");
        const retentionMilestonesEl = document.getElementById("stats-chart-retention-milestones");
        const longevityHeatmapEl = document.getElementById("stats-chart-longevity-heatmap");
        const retentionHeatmapEl = document.getElementById("stats-chart-retention-heatmap");
        const retentionIntensityEl = document.getElementById("stats-chart-retention-intensity-heatmap");
        const granularityEl = document.getElementById("stats-granularity");
        const retentionGranularityEl = document.getElementById("stats-retention-granularity");
        const retentionSegmentEl = document.getElementById("stats-retention-segment");
        const rangeEl = document.getElementById("stats-range");
        const fromEl = document.getElementById("stats-from");
        const toEl = document.getElementById("stats-to");
        const applyRangeEl = document.getElementById("stats-apply-range");
        const customRangeEls = Array.from(document.querySelectorAll(".stats-custom-range"));
        function getCSSVar(name) {
          return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
        }

        function getChartColors() {
          return {
            textColor: getCSSVar('--color-chart-text'),
            cardBg: getCSSVar('--color-chart-bg'),
            borderColor: getCSSVar('--color-chart-border')
          };
        }

        const chartSeries = {
          main: [
            { key: "participants_active", label: "Active participants", color: getCSSVar('--color-chart-blue') },
            { key: "participants_new", label: "New participants", color: getCSSVar('--color-chart-cyan') },
            { key: "retained_365_participants", label: "Retained participants (365d+)", color: getCSSVar('--color-chart-green') },
            { key: "new_users_replied_to_others", label: "New participants replying to others", color: getCSSVar('--color-chart-light-red') },
            { key: "topics_new", label: "New topics", color: getCSSVar('--color-chart-purple') },
            { key: "topics_new_by_new_users", label: "New topics by new users", color: getCSSVar('--color-chart-light-purple') },
            { key: "topics_new_with_attachments_by_new_users", label: "New topics with attachments by new users", color: getCSSVar('--color-chart-light-brown') },
            { key: "topics_active", label: "Active topics", color: getCSSVar('--color-chart-brown') },
            { key: "topics_new_with_contributor_activity", label: "New topics with contributor activity", color: getCSSVar('--color-chart-pink') },
            { key: "topics_new_without_contributor_activity", label: "New topics without contributor activity", color: getCSSVar('--color-chart-gray') },
            { key: "messages_total", label: "Total messages", color: getCSSVar('--color-chart-orange') },
            { key: "messages_committers", label: "Messages by committers", color: getCSSVar('--color-chart-red') },
            { key: "messages_contributors", label: "Messages by contributors", color: getCSSVar('--color-chart-yellow-green') },
            { key: "messages_new_participants", label: "Messages by new participants", color: getCSSVar('--color-chart-light-blue') },
            { key: "topics_messages_avg", label: "Active topic avg msgs", color: getCSSVar('--color-chart-blue') },
            { key: "topics_messages_median", label: "Active topic median msgs", color: getCSSVar('--color-chart-orange') },
            { key: "topics_messages_max", label: "Active topic max msgs", color: getCSSVar('--color-chart-green') },
            { key: "topics_created_messages_avg", label: "New topic avg msgs", color: getCSSVar('--color-chart-blue') },
            { key: "topics_created_messages_median", label: "New topic median msgs", color: getCSSVar('--color-chart-orange') },
            { key: "topics_created_messages_max", label: "New topic max msgs", color: getCSSVar('--color-chart-green') },
            { key: "topic_longevity_avg_days", label: "Topic longevity avg days", color: getCSSVar('--color-chart-purple') },
            { key: "topic_longevity_median_days", label: "Topic longevity median days", color: getCSSVar('--color-chart-brown') },
            { key: "topic_longevity_max_days", label: "Topic longevity max days", color: getCSSVar('--color-chart-red') },
            { key: "new_participants_lifetime_avg_days", label: "New participant lifetime avg days", color: getCSSVar('--color-chart-blue') },
            { key: "new_participants_lifetime_median_days", label: "New participant lifetime median days", color: getCSSVar('--color-chart-orange') },
            { key: "new_participants_lifetime_max_days", label: "New participant lifetime max days", color: getCSSVar('--color-chart-green') },
            { key: "retained_365_lifetime_avg_days", label: "Retained lifetime avg days", color: getCSSVar('--color-chart-purple') },
            { key: "retained_365_lifetime_median_days", label: "Retained lifetime median days", color: getCSSVar('--color-chart-brown') },
            { key: "new_participants_daily_avg_messages", label: "New participant daily avg msgs", color: getCSSVar('--color-chart-blue') },
            { key: "retained_365_daily_avg_messages", label: "Retained daily avg msgs", color: getCSSVar('--color-chart-orange') }
          ],
          depth: [
            { key: "topics_messages_avg", label: "Avg messages", color: getCSSVar('--color-chart-blue') },
            { key: "topics_messages_median", label: "Median messages", color: getCSSVar('--color-chart-orange') },
            { key: "topics_messages_max", label: "Max messages", color: getCSSVar('--color-chart-green') }
          ],
          created_depth: [
            { key: "topics_created_messages_avg", label: "Avg messages", color: getCSSVar('--color-chart-blue') },
            { key: "topics_created_messages_median", label: "Median messages", color: getCSSVar('--color-chart-orange') },
            { key: "topics_created_messages_max", label: "Max messages", color: getCSSVar('--color-chart-green') }
          ],
          message_breakdown: [
            { key: "messages_committers", label: "Committers", color: getCSSVar('--color-chart-red') },
            { key: "messages_contributors_non_committers", label: "Contributors (non-committers)", color: getCSSVar('--color-chart-yellow-green') },
            { key: "messages_new_participants", label: "New participants", color: getCSSVar('--color-chart-light-blue') },
            { key: "messages_regular_participants", label: "Regular participants", color: getCSSVar('--color-chart-gray') }
          ],
          attachments: [
            { key: "topics_new_no_attachments", label: "No attachments", color: getCSSVar('--color-chart-light-gray') },
            { key: "topics_new_with_attachments_no_commitfest", label: "Attachment, not commitfest", color: getCSSVar('--color-chart-blue') },
            { key: "topics_new_commitfest_in_progress", label: "Commitfest in progress", color: getCSSVar('--color-chart-orange') },
            { key: "topics_new_commitfest_abandoned", label: "Commitfest rejected", color: getCSSVar('--color-chart-red') },
            { key: "topics_new_commitfest_committed", label: "Commitfest committed", color: getCSSVar('--color-chart-green') }
          ],
          new_topic_attachments: [
            { key: "topics_new_by_new_users_no_attachments", label: "New users, no attachments", color: getCSSVar('--color-chart-silver') },
            { key: "topics_new_by_new_users_with_attachments", label: "New users, attachments", color: getCSSVar('--color-chart-steel-blue') },
            { key: "topics_new_by_existing_users_no_attachments", label: "Existing users, no attachments", color: getCSSVar('--color-chart-dark-gray') },
            { key: "topics_new_by_existing_users_with_attachments", label: "Existing users, attachments", color: getCSSVar('--color-chart-medium-blue') }
          ],
          longevity: [
            { key: "topic_longevity_avg_days", label: "Avg days", color: getCSSVar('--color-chart-purple') },
            { key: "topic_longevity_median_days", label: "Median days", color: getCSSVar('--color-chart-brown') },
            { key: "topic_longevity_max_days", label: "Max days", color: getCSSVar('--color-chart-red') }
          ],
          participant_lifetime: [
            { key: "new_participants_lifetime_avg_days", label: "New avg days", color: getCSSVar('--color-chart-blue') },
            { key: "new_participants_lifetime_median_days", label: "New median days", color: getCSSVar('--color-chart-orange') },
            { key: "new_participants_lifetime_max_days", label: "New max days", color: getCSSVar('--color-chart-green') },
            { key: "retained_365_lifetime_avg_days", label: "Retained avg days", color: getCSSVar('--color-chart-purple') },
            { key: "retained_365_lifetime_median_days", label: "Retained median days", color: getCSSVar('--color-chart-brown') }
          ],
          new_participant_rate: [
            { key: "new_participants_daily_avg_messages", label: "New participants", color: getCSSVar('--color-chart-blue') },
            { key: "retained_365_daily_avg_messages", label: "Retained 365d+", color: getCSSVar('--color-chart-orange') }
          ],
          participant_retention: [
            { key: "retained_365_participants", label: "Retained 365d+", color: getCSSVar('--color-chart-orange') },
            { key: "participants_new_not_retained_365", label: "New (not retained)", color: getCSSVar('--color-chart-blue') }
          ],
          retention_milestones: [
            { key: "retention_q1", label: "3m+", color: getCSSVar('--color-chart-blue') },
            { key: "retention_q2", label: "6m+", color: getCSSVar('--color-chart-orange') },
            { key: "retention_q4", label: "1y+", color: getCSSVar('--color-chart-green') },
            { key: "retention_q6", label: "1.5y+", color: getCSSVar('--color-chart-red') },
            { key: "retention_q8", label: "2y+", color: getCSSVar('--color-chart-purple') },
            { key: "retention_q10", label: "2.5y+", color: getCSSVar('--color-chart-brown') },
            { key: "retention_q12", label: "3y+", color: getCSSVar('--color-chart-pink') },
            { key: "retention_q16", label: "4y+", color: getCSSVar('--color-chart-gray') },
            { key: "retention_q20", label: "5y+", color: getCSSVar('--color-chart-cyan') }
          ]
        };

        const chartConfigs = {
          main: {
            key: "main",
            el: mainEl,
            editorEl: document.getElementById("stats-editor-main"),
            applyEl: document.getElementById("stats-editor-apply-main"),
            height: 320
          },
          depth: {
            key: "depth",
            el: depthEl,
            editorEl: document.getElementById("stats-editor-depth"),
            applyEl: document.getElementById("stats-editor-apply-depth"),
            height: 220
          },
          created_depth: {
            key: "created_depth",
            el: createdDepthEl,
            editorEl: document.getElementById("stats-editor-created-depth"),
            applyEl: document.getElementById("stats-editor-apply-created-depth"),
            height: 220
          },
          message_breakdown: {
            key: "message_breakdown",
            el: messageBreakdownEl,
            editorEl: document.getElementById("stats-editor-message-breakdown"),
            applyEl: document.getElementById("stats-editor-apply-message-breakdown"),
            height: 260,
            type: "stacked_bar"
          },
          attachments: {
            key: "attachments",
            el: attachmentsEl,
            editorEl: document.getElementById("stats-editor-attachments"),
            applyEl: document.getElementById("stats-editor-apply-attachments"),
            height: 260,
            type: "stacked_bar"
          },
          new_topic_attachments: {
            key: "new_topic_attachments",
            el: newTopicAttachmentsEl,
            editorEl: document.getElementById("stats-editor-new-topic-attachments"),
            applyEl: document.getElementById("stats-editor-apply-new-topic-attachments"),
            height: 260,
            type: "stacked_bar"
          },
          longevity: {
            key: "longevity",
            el: longevityEl,
            editorEl: document.getElementById("stats-editor-longevity"),
            applyEl: document.getElementById("stats-editor-apply-longevity"),
            height: 220
          },
          participant_lifetime: {
            key: "participant_lifetime",
            el: participantLifetimeEl,
            editorEl: document.getElementById("stats-editor-participant-lifetime"),
            applyEl: document.getElementById("stats-editor-apply-participant-lifetime"),
            height: 220
          },
          new_participant_rate: {
            key: "new_participant_rate",
            el: newParticipantRateEl,
            editorEl: document.getElementById("stats-editor-new-participant-rate"),
            applyEl: document.getElementById("stats-editor-apply-new-participant-rate"),
            height: 220
          },
          participant_retention: {
            key: "participant_retention",
            el: participantRetentionEl,
            editorEl: document.getElementById("stats-editor-participant-retention"),
            applyEl: document.getElementById("stats-editor-apply-participant-retention"),
            height: 240,
            type: "stacked_bar"
          },
          retention_milestones: {
            key: "retention_milestones",
            el: retentionMilestonesEl,
            editorEl: document.getElementById("stats-editor-retention-milestones"),
            applyEl: document.getElementById("stats-editor-apply-retention-milestones"),
            height: 260,
            type: "overlay_bar"
          }
        };

        const collapsibleKeys = [
          "main",
          "depth",
          "created_depth",
          "message_breakdown",
          "attachments",
          "new_topic_attachments",
          "longevity",
          "longevity_heatmap",
          "participant_lifetime",
          "new_participant_rate",
          "participant_retention",
          "retention_milestones",
          "retention_heatmap",
          "retention_intensity"
        ];

        function applySeriesSwatches() {
          const swatches = Array.from(document.querySelectorAll(".series-swatch[data-chart][data-series]"));
          swatches.forEach(swatch => {
            const chartKey = swatch.dataset.chart;
            const seriesKey = swatch.dataset.series;
            const series = chartSeries[chartKey]?.find(entry => entry.key === seriesKey);
            if (!series) return;
            swatch.style.display = "inline-block";
            swatch.style.width = "10px";
            swatch.style.height = "10px";
            swatch.style.marginRight = "6px";
            swatch.style.borderRadius = "2px";
            swatch.style.backgroundColor = series.color || "#666";
            swatch.style.border = "1px solid rgba(0, 0, 0, 0.2)";
            swatch.style.verticalAlign = "middle";
          });
        }

        Object.values(chartConfigs).forEach(config => {
          config.seriesInputs = Array.from(document.querySelectorAll(`input[type="checkbox"][data-chart="${config.key}"][data-series]`));
        });

        const collapsibleByKey = new Map();
        document.querySelectorAll("[data-collapsible]").forEach(el => {
          const key = el.dataset.collapsible;
          if (key) collapsibleByKey.set(key, el);
        });

        function setCollapsedState(key, collapsed) {
          const container = collapsibleByKey.get(key);
          if (!container) return;
          container.open = !collapsed;
        }

        function encodeCollapseFlags() {
          return collapsibleKeys.map(key => {
            const container = collapsibleByKey.get(key);
            return container && !container.open ? "1" : "0";
          }).join("");
        }

        function applyCollapseFlags(flags) {
          if (!flags || flags.length !== collapsibleKeys.length) return;
          collapsibleKeys.forEach((key, idx) => {
            setCollapsedState(key, flags[idx] === "1");
          });
        }

        function seriesKeysFor(chartKey) {
          return chartSeries[chartKey].map(series => series.key);
        }

        function selectedSeriesFor(chartKey) {
          const inputs = chartConfigs[chartKey].seriesInputs;
          const selectedKeys = inputs.filter(input => input.checked).map(input => input.dataset.series);
          return chartSeries[chartKey].filter(series => selectedKeys.includes(series.key));
        }

        function encodeSeriesFlags(keys, selectedKeys) {
          return keys.map(key => (selectedKeys.includes(key) ? "1" : "0")).join("");
        }

        function encodeSeriesFlagsFor(chartKey) {
          const keys = seriesKeysFor(chartKey);
          const selectedKeys = selectedSeriesFor(chartKey).map(series => series.key);
          return encodeSeriesFlags(keys, selectedKeys);
        }

        function applySeriesFlags(flags, chartKey) {
          const keys = seriesKeysFor(chartKey);
          const inputs = chartConfigs[chartKey].seriesInputs;
          if (!flags || flags.length !== keys.length) return;
          inputs.forEach((input, idx) => {
            input.checked = flags[idx] === "1";
          });
        }

        function formatDate(value) {
          return new Date(value).toISOString().slice(0, 10);
        }

        function fetchData() {
          const granularity = granularityEl.value;
          const range = rangeEl.value;
          const retentionGranularity = retentionGranularityEl.value;
          const retentionSegment = retentionSegmentEl.value;
          let url = `/stats/data?granularity=${granularity}&range=${range}`;
          url += `&retention_granularity=${retentionGranularity}`;
          url += `&retention_segment=${retentionSegment}`;
          if (range === "custom") {
            const from = fromEl.value;
            const to = toEl.value;
            if (from && to) {
              url += `&from=${encodeURIComponent(from)}&to=${encodeURIComponent(to)}`;
            }
          }
          return fetch(url)
            .then(resp => resp.json());
        }

        function syncUrl() {
          const granularity = granularityEl.value;
          const range = rangeEl.value;
          const retentionGranularity = retentionGranularityEl.value;
          const retentionSegment = retentionSegmentEl.value;
          const params = new URLSearchParams();
          params.set("granularity", granularity);
          params.set("range", range);
          params.set("retention_granularity", retentionGranularity);
          params.set("retention_segment", retentionSegment);
          params.set("collapsed", encodeCollapseFlags());
          params.set("series_main", encodeSeriesFlagsFor("main"));
          params.set("series_depth", encodeSeriesFlagsFor("depth"));
          params.set("series_created_depth", encodeSeriesFlagsFor("created_depth"));
          params.set("series_message_breakdown", encodeSeriesFlagsFor("message_breakdown"));
          params.set("series_attachments", encodeSeriesFlagsFor("attachments"));
          params.set("series_new_topic_attachments", encodeSeriesFlagsFor("new_topic_attachments"));
          params.set("series_longevity", encodeSeriesFlagsFor("longevity"));
          params.set("series_participant_lifetime", encodeSeriesFlagsFor("participant_lifetime"));
          params.set("series_new_participant_rate", encodeSeriesFlagsFor("new_participant_rate"));
          params.set("series_participant_retention", encodeSeriesFlagsFor("participant_retention"));
          params.set("series_retention_milestones", encodeSeriesFlagsFor("retention_milestones"));
          if (range === "custom") {
            if (fromEl.value) params.set("from", fromEl.value);
            if (toEl.value) params.set("to", toEl.value);
          }
          const next = `${window.location.pathname}?${params.toString()}`;
          window.history.replaceState({}, "", next);
        }

        function hydrateControlsFromUrl() {
          const params = new URLSearchParams(window.location.search);
          const granularity = params.get("granularity");
          const range = params.get("range");
          const retentionGranularity = params.get("retention_granularity");
          const retentionSegment = params.get("retention_segment");
          const from = params.get("from");
          const to = params.get("to");
          const collapsed = params.get("collapsed");
          const seriesMain = params.get("series_main") || params.get("series");
          const seriesDepth = params.get("series_depth");
          const seriesCreatedDepth = params.get("series_created_depth");
          const seriesMessageBreakdown = params.get("series_message_breakdown");
          const seriesAttachments = params.get("series_attachments");
          const seriesNewTopicAttachments = params.get("series_new_topic_attachments");
          const seriesLongevity = params.get("series_longevity");
          const seriesParticipantLifetime = params.get("series_participant_lifetime");
          const seriesNewParticipantRate = params.get("series_new_participant_rate");
          const seriesParticipantRetention = params.get("series_participant_retention");
          const seriesRetentionMilestones = params.get("series_retention_milestones");

          if (granularity) granularityEl.value = granularity;
          if (range) rangeEl.value = range;
          if (retentionGranularity) retentionGranularityEl.value = retentionGranularity;
          if (retentionSegment) retentionSegmentEl.value = retentionSegment;
          if (from) fromEl.value = from;
          if (to) toEl.value = to;
          applyCollapseFlags(collapsed);
          applySeriesFlags(seriesMain, "main");
          applySeriesFlags(seriesDepth, "depth");
          applySeriesFlags(seriesCreatedDepth, "created_depth");
          applySeriesFlags(seriesMessageBreakdown, "message_breakdown");
          applySeriesFlags(seriesAttachments, "attachments");
          applySeriesFlags(seriesNewTopicAttachments, "new_topic_attachments");
          applySeriesFlags(seriesLongevity, "longevity");
          applySeriesFlags(seriesParticipantLifetime, "participant_lifetime");
          applySeriesFlags(seriesNewParticipantRate, "new_participant_rate");
          applySeriesFlags(seriesParticipantRetention, "participant_retention");
          if (seriesRetentionMilestones) {
            applySeriesFlags(seriesRetentionMilestones, "retention_milestones");
          }
          toggleCustomRange();
        }

        function decorateIntervals(intervals) {
          return intervals.map(row => {
          const intervalKey = row.interval_start;
          const intervalTs = Date.parse(`${intervalKey}T00:00:00Z`);
          const messages_total = row.messages_total || 0;
          const messages_committers = row.messages_committers || 0;
          const messages_contributors = row.messages_contributors || 0;
          const contributors_non_committers = Math.max(messages_contributors - messages_committers, 0);
          const messages_new = row.messages_new_participants || 0;
          const messages_regular = Math.max(
              messages_total - messages_committers - contributors_non_committers - messages_new,
              0
            );
          const topics_new = row.topics_new || 0;
          const participants_new = row.participants_new || 0;
          const retained_365_participants = row.retained_365_participants || 0;
          const participants_new_not_retained_365 = Math.max(participants_new - retained_365_participants, 0);
          const topics_new_no_attachments = row.topics_new_no_attachments || 0;
          const topics_new_commitfest_in_progress = row.topics_new_commitfest_in_progress || 0;
          const topics_new_commitfest_abandoned = row.topics_new_commitfest_abandoned || 0;
          const topics_new_commitfest_committed = row.topics_new_commitfest_committed || 0;
          const topics_new_with_attachments = Math.max(topics_new - topics_new_no_attachments, 0);
          const topics_new_commitfest_total = (
            topics_new_commitfest_in_progress +
            topics_new_commitfest_abandoned +
            topics_new_commitfest_committed
          );
          const topics_new_with_attachments_no_commitfest = row.topics_new_with_attachments_no_commitfest ?? Math.max(
            topics_new_with_attachments - topics_new_commitfest_total,
            0
          );
          const topics_new_by_new_users = row.topics_new_by_new_users || 0;
          const topics_new_by_new_users_with_attachments = row.topics_new_with_attachments_by_new_users || 0;
          const topics_new_by_new_users_no_attachments = Math.max(
            topics_new_by_new_users - topics_new_by_new_users_with_attachments,
            0
          );
          const topics_new_by_existing_users = Math.max(topics_new - topics_new_by_new_users, 0);
          const topics_new_by_existing_users_with_attachments = Math.max(
            topics_new_with_attachments - topics_new_by_new_users_with_attachments,
            0
          );
          const topics_new_by_existing_users_no_attachments = Math.max(
            topics_new_by_existing_users - topics_new_by_existing_users_with_attachments,
            0
          );
            return Object.assign({}, row, {
              interval_key: intervalKey,
              interval_ts: intervalTs,
              messages_contributors_non_committers: contributors_non_committers,
              messages_regular_participants: messages_regular,
              pct_messages_committers: messages_total ? row.messages_committers / messages_total : 0,
              pct_messages_contributors: messages_total ? row.messages_contributors / messages_total : 0,
              pct_topics_new_without_contributor_activity: topics_new ? row.topics_new_without_contributor_activity / topics_new : 0,
              participants_new_not_retained_365: participants_new_not_retained_365,
              topics_new_no_attachments: topics_new_no_attachments,
              topics_new_with_attachments_no_commitfest: topics_new_with_attachments_no_commitfest,
              topics_new_commitfest_in_progress: topics_new_commitfest_in_progress,
              topics_new_commitfest_abandoned: topics_new_commitfest_abandoned,
              topics_new_commitfest_committed: topics_new_commitfest_committed,
              topics_new_by_new_users_no_attachments: topics_new_by_new_users_no_attachments,
              topics_new_by_new_users_with_attachments: topics_new_by_new_users_with_attachments,
              topics_new_by_existing_users_no_attachments: topics_new_by_existing_users_no_attachments,
              topics_new_by_existing_users_with_attachments: topics_new_by_existing_users_with_attachments
            });
          });
        }

        function chartWidthFor(el) {
          if (!el?.getBoundingClientRect) return 320;
          const container = el.parentElement || el;
          const containerWidth = container.getBoundingClientRect().width;
          const style = window.getComputedStyle(el);
          const padding =
            (parseFloat(style.paddingLeft) || 0) +
            (parseFloat(style.paddingRight) || 0);
          const border =
            (parseFloat(style.borderLeftWidth) || 0) +
            (parseFloat(style.borderRightWidth) || 0);
          const width = containerWidth - padding - border - 20;
          return Math.max(320, Math.floor(width));
        }

        function buildLineSpec(intervals, width, height, enabledSeries) {
          const chartColors = getChartColors();
          const points = intervals.flatMap(row => (
            enabledSeries.map(series => ({
              interval_ts: row.interval_ts,
              series: series.key,
              series_label: series.label,
              value: row[series.key] || 0
            }))
          ));
          const marks = enabledSeries.map(series => ({
            type: "line",
            from: { data: "stats" },
            encode: {
              enter: {
                x: { scale: "x", field: "interval_ts" },
                y: { scale: "y", field: series.key },
                stroke: { value: series.color || "#666" },
                strokeWidth: { value: 2 },
                interpolate: { value: "step-after" }
              }
            }
          }));

          const spec = {
            $schema: "https://vega.github.io/schema/vega/v5.json",
            width: width,
            height: height,
            padding: 10,
            autosize: { type: "fit", contains: "padding" },
            scales: [
              { name: "x", type: "time", domain: { data: "stats", field: "interval_ts" }, range: "width" },
              { name: "y", type: "linear", domain: { data: "stats", fields: enabledSeries.map(series => series.key) }, nice: true, range: "height" },
              { name: "color", type: "ordinal", domain: enabledSeries.map(series => series.key), range: enabledSeries.map(series => series.color || "#666") }
            ],
            axes: [
              { orient: "bottom", scale: "x", format: "%Y-%m-%d", formatType: "utc", labelOverlap: true, labelColor: chartColors.textColor, tickColor: chartColors.textColor, domainColor: chartColors.textColor },
              { orient: "left", scale: "y", labelColor: chartColors.textColor, tickColor: chartColors.textColor, domainColor: chartColors.textColor }
            ],
            signals: [
              { name: "hoverTs", value: null, on: [
                { events: "mousemove", update: "clamp(invert('x', x()), domain('x')[0], domain('x')[1])" },
                { events: "mouseout", update: "null" }
              ] }
            ],
            data: [
              { name: "stats", values: intervals },
              { name: "points", values: points },
              {
                name: "hover_points",
                source: "points",
                transform: [
                  { type: "formula", as: "dist", expr: "hoverTs == null ? null : abs(datum.interval_ts - hoverTs)" },
                  { type: "window", sort: { field: "dist", order: "ascending" }, groupby: ["series"], ops: ["row_number"], as: ["rank"] },
                  { type: "filter", expr: "hoverTs != null && datum.rank == 1" },
                  { type: "window", sort: { field: "series_label", order: "ascending" }, ops: ["row_number"], as: ["idx"] }
                ]
              }
            ],
            marks: marks.concat([
              {
                type: "rule",
                encode: {
                  update: {
                    x: { scale: "x", signal: "hoverTs" },
                    y: { value: 0 },
                    y2: { signal: "height" },
                    stroke: { value: "#c7c7c7" },
                    strokeWidth: { value: 1 },
                    opacity: { signal: "hoverTs == null ? 0 : 1" }
                  }
                }
              },
              {
                type: "symbol",
                from: { data: "hover_points" },
                encode: {
                  enter: {
                    x: { scale: "x", field: "interval_ts" },
                    y: { scale: "y", field: "value" },
                    size: { value: 64 },
                    fill: { scale: "color", field: "series" },
                    opacity: { value: 1 }
                  }
                }
              },
              {
                type: "group",
                encode: {
                  enter: {
                    x: { signal: "clamp(scale('x', hoverTs) + 10, 10, width - 240)" },
                    y: { value: 10 }
                  }
                },
                marks: [
                  {
                    type: "rect",
                    encode: {
                      update: {
                        x: { value: 0 },
                        y: { value: 0 },
                        width: { value: 230 },
                        height: { signal: "32 + data('hover_points').length * 18" },
                        fill: { value: "white" },
                        stroke: { value: "#d0d0d0" },
                        cornerRadius: { value: 6 },
                        opacity: { signal: "hoverTs == null ? 0 : 1" }
                      }
                    }
                  },
                  {
                    type: "text",
                    encode: {
                      update: {
                        x: { value: 10 },
                        y: { value: 16 },
                        text: { signal: "hoverTs == null ? '' : timeFormat(hoverTs, '%Y-%m-%d')" },
                        fontWeight: { value: "600" },
                        fill: { value: "#111" },
                        opacity: { signal: "hoverTs == null ? 0 : 1" }
                      }
                    }
                  },
                  {
                    type: "text",
                    from: { data: "hover_points" },
                    encode: {
                      update: {
                        x: { value: 10 },
                        y: { signal: "30 + (datum.idx - 1) * 18" },
                        text: { signal: "datum.series_label + ': ' + datum.value" },
                        fill: { value: "#111" },
                        opacity: { signal: "hoverTs == null ? 0 : 1" }
                      }
                    }
                  }
                ]
              }
            ])
          };
          return { spec: spec, points: points };
        }

        function buildStackedBarSpec(intervals, width, height, enabledSeries) {
          const chartColors = getChartColors();
          const seriesOrder = new Map(enabledSeries.map((series, idx) => [series.key, idx]));
          const points = intervals.flatMap(row => (
            enabledSeries.map(series => ({
              interval_ts: row.interval_ts,
              series: series.key,
              series_label: series.label,
              series_order: seriesOrder.get(series.key) ?? 0,
              value: row[series.key] || 0
            }))
          ));
          const barWidth = Math.max(6, Math.floor(width / Math.max(intervals.length, 1) * 0.75));
          const spec = {
            $schema: "https://vega.github.io/schema/vega/v5.json",
            width: width,
            height: height,
            padding: 10,
            autosize: { type: "fit", contains: "padding" },
            signals: [
              { name: "hoverTs", value: null, on: [
                { events: "mousemove", update: "clamp(invert('x', x()), domain('x')[0], domain('x')[1])" },
                { events: "mouseout", update: "null" }
              ] },
              { name: "barWidth", value: barWidth }
            ],
            data: [
              { name: "stats", values: intervals },
              { name: "points", values: points },
              {
                name: "stacked",
                source: "points",
                transform: [
                  { type: "stack", groupby: ["interval_ts"], field: "value", sort: { field: "series_order", order: "ascending" } }
                ]
              },
              {
                name: "stack_sums",
                source: "points",
                transform: [
                  { type: "aggregate", groupby: ["interval_ts"], fields: ["value"], ops: ["sum"], as: ["total"] }
                ]
              },
              {
                name: "trend",
                source: "stack_sums",
                transform: [
                  { type: "loess", x: "interval_ts", y: "total", bandwidth: 0.3 }
                ]
              },
              {
                name: "hover_points",
                source: "points",
                transform: [
                  { type: "formula", as: "dist", expr: "hoverTs == null ? null : abs(datum.interval_ts - hoverTs)" },
                  { type: "window", sort: { field: "dist", order: "ascending" }, groupby: ["series"], ops: ["row_number"], as: ["rank"] },
                  { type: "filter", expr: "hoverTs != null && datum.rank == 1" },
                  { type: "window", sort: { field: "series_label", order: "ascending" }, ops: ["row_number"], as: ["idx"] }
                ]
              }
            ],
            scales: [
              { name: "x", type: "time", domain: { data: "stats", field: "interval_ts" }, range: "width" },
              { name: "y", type: "linear", domain: { data: "stack_sums", field: "total" }, nice: true, range: "height" },
              { name: "color", type: "ordinal", domain: enabledSeries.map(series => series.key), range: enabledSeries.map(series => series.color || "#666") }
            ],
            axes: [
              { orient: "bottom", scale: "x", format: "%Y-%m-%d", formatType: "utc", labelOverlap: true, labelColor: chartColors.textColor, tickColor: chartColors.textColor, domainColor: chartColors.textColor },
              { orient: "left", scale: "y", labelColor: chartColors.textColor, tickColor: chartColors.textColor, domainColor: chartColors.textColor }
            ],
            marks: [
              {
                type: "rect",
                from: { data: "stacked" },
                encode: {
                  enter: {
                    x: { signal: "scale('x', datum.interval_ts) - barWidth / 2" },
                    width: { signal: "barWidth" },
                    y: { scale: "y", field: "y1" },
                    y2: { scale: "y", field: "y0" },
                    fill: { scale: "color", field: "series" }
                  }
                }
              },
              {
                type: "line",
                from: { data: "trend" },
                encode: {
                  enter: {
                    x: { scale: "x", field: "interval_ts" },
                    y: { scale: "y", field: "total" },
                    stroke: { value: "#111" },
                    strokeWidth: { value: 2 },
                    opacity: { value: 0.6 }
                  }
                }
              },
              {
                type: "rule",
                encode: {
                  update: {
                    x: { scale: "x", signal: "hoverTs" },
                    y: { value: 0 },
                    y2: { signal: "height" },
                    stroke: { value: "#c7c7c7" },
                    strokeWidth: { value: 1 },
                    opacity: { signal: "hoverTs == null ? 0 : 1" }
                  }
                }
              },
              {
                type: "group",
                encode: {
                  enter: {
                    x: { signal: "clamp(scale('x', hoverTs) + 10, 10, width - 240)" },
                    y: { value: 10 }
                  }
                },
                marks: [
                  {
                    type: "rect",
                    encode: {
                      update: {
                        x: { value: 0 },
                        y: { value: 0 },
                        width: { value: 230 },
                        height: { signal: "32 + data('hover_points').length * 18" },
                        fill: { value: "white" },
                        stroke: { value: "#d0d0d0" },
                        cornerRadius: { value: 6 },
                        opacity: { signal: "hoverTs == null ? 0 : 1" }
                      }
                    }
                  },
                  {
                    type: "text",
                    encode: {
                      update: {
                        x: { value: 10 },
                        y: { value: 16 },
                        text: { signal: "hoverTs == null ? '' : timeFormat(hoverTs, '%Y-%m-%d')" },
                        fontWeight: { value: "600" },
                        fill: { value: "#111" },
                        opacity: { signal: "hoverTs == null ? 0 : 1" }
                      }
                    }
                  },
                  {
                    type: "text",
                    from: { data: "hover_points" },
                    encode: {
                      update: {
                        x: { value: 10 },
                        y: { signal: "30 + (datum.idx - 1) * 18" },
                        text: { signal: "datum.series_label + ': ' + datum.value" },
                        fill: { value: "#111" },
                        opacity: { signal: "hoverTs == null ? 0 : 1" }
                      }
                    }
                  }
                ]
              }
            ]
          };
          return { spec: spec, points: points };
        }

        function buildOverlayBarSpec(intervals, width, height, enabledSeries) {
          const chartColors = getChartColors();
          if (!intervals.length) {
            return { spec: null, points: [] };
          }
          const points = intervals.flatMap(row => (
            enabledSeries.map((series, idx) => ({
              interval_key: row.interval_key,
              interval_ts: row.interval_ts,
              series: series.key,
              series_label: series.label,
              value: row[series.key] || 0,
              color: series.color || "#666",
              order: idx + 1
            }))
          ));
          const spec = {
            $schema: "https://vega.github.io/schema/vega/v5.json",
            width: width,
            height: height,
            padding: 10,
            autosize: { type: "fit", contains: "padding" },
            signals: [
              { name: "hoverKey", value: null, on: [
                { events: "@bands:mousemove", update: "datum.interval_key" },
                { events: "@bands:mouseout", update: "null" }
              ] }
            ],
            data: [
              { name: "points", values: points },
              {
                name: "hover_points",
                source: "points",
                transform: [
                  { type: "filter", expr: "hoverKey != null && datum.interval_key === hoverKey" },
                  { type: "collect", sort: { field: "order", order: "ascending" } },
                  { type: "window", ops: ["row_number"], as: ["idx"] }
                ]
              }
            ],
            scales: [
              { name: "x", type: "band", domain: { data: "points", field: "interval_key" }, range: "width", padding: 0.2 },
              { name: "y", type: "linear", domain: [0, 1], nice: false, range: "height" }
            ],
            axes: [
              { orient: "bottom", scale: "x", labelOverlap: true, labelColor: chartColors.textColor, tickColor: chartColors.textColor, domainColor: chartColors.textColor },
              { orient: "left", scale: "y", format: ".0%", labelColor: chartColors.textColor, tickColor: chartColors.textColor, domainColor: chartColors.textColor }
            ],
            marks: [
              {
                type: "rect",
                from: { data: "points" },
                encode: {
                  enter: {
                    x: { scale: "x", field: "interval_key" },
                    width: { scale: "x", band: 1 },
                    y: { scale: "y", field: "value" },
                    y2: { scale: "y", value: 0 },
                    fill: { field: "color" },
                    opacity: { value: 1 },
                    zindex: { field: "order" }
                  }
                }
              },
              {
                name: "bands",
                type: "rect",
                from: { data: "points" },
                encode: {
                  enter: {
                    x: { scale: "x", field: "interval_key" },
                    width: { scale: "x", band: 1 },
                    y: { value: 0 },
                    y2: { signal: "height" },
                    fill: { value: "transparent" }
                  }
                }
              },
              {
                type: "rule",
                encode: {
                  update: {
                    x: { signal: "hoverKey == null ? 0 : scale('x', hoverKey) + bandwidth('x') / 2" },
                    y: { value: 0 },
                    y2: { signal: "height" },
                    stroke: { value: "#c7c7c7" },
                    strokeWidth: { value: 1 },
                    opacity: { signal: "hoverKey == null ? 0 : 1" }
                  }
                }
              },
              {
                type: "group",
                encode: {
                  enter: {
                    x: { signal: "clamp(scale('x', hoverKey) + 10, 10, width - 240)" },
                    y: { value: 10 }
                  }
                },
                marks: [
                  {
                    type: "rect",
                    encode: {
                      update: {
                        x: { value: 0 },
                        y: { value: 0 },
                        width: { value: 230 },
                        height: { signal: "32 + data('hover_points').length * 18" },
                        fill: { value: "white" },
                        stroke: { value: "#d0d0d0" },
                        cornerRadius: { value: 6 },
                        opacity: { signal: "hoverKey == null ? 0 : 1" }
                      }
                    }
                  },
                  {
                    type: "text",
                    encode: {
                      update: {
                        x: { value: 10 },
                        y: { value: 16 },
                        text: { signal: "hoverKey == null ? '' : timeFormat(toDate(hoverKey), '%Y-%m')" },
                        fontWeight: { value: "600" },
                        fill: { value: "#111" },
                        opacity: { signal: "hoverKey == null ? 0 : 1" }
                      }
                    }
                  },
                  {
                    type: "text",
                    from: { data: "hover_points" },
                    encode: {
                      update: {
                        x: { value: 10 },
                        y: { signal: "30 + (datum.idx - 1) * 18" },
                        text: { signal: "datum.series_label + ': ' + format(datum.value, '.1%')" },
                        fill: { value: "#111" },
                        opacity: { signal: "hoverKey == null ? 0 : 1" }
                      }
                    }
                  }
                ]
              }
            ]
          };
          return { spec: spec, points: points };
        }

        function buildLongevityHeatmapSpec(histogram, width) {
          const chartColors = getChartColors();
          const bucketOrder = ["0-1", "2-7", "8-30", "31-90", "91-180", "181-365", "365+"];
          const points = histogram.map(row => ({
            interval_ts: Date.parse(`${row.interval_start}T00:00:00Z`),
            bucket: row.bucket,
            count: row.count || 0
          }));
          return {
            $schema: "https://vega.github.io/schema/vega/v5.json",
            width: width,
            height: 260,
            padding: 10,
            autosize: { type: "fit", contains: "padding" },
            data: [{ name: "heat", values: points }],
            scales: [
              { name: "x", type: "time", domain: { data: "heat", field: "interval_ts" }, range: "width" },
              { name: "y", type: "band", domain: bucketOrder, range: "height", padding: 0.1 },
              { name: "color", type: "linear", domain: { data: "heat", field: "count" }, nice: true, range: ["#f2f0f7", "#54278f"] }
            ],
            axes: [
              { orient: "bottom", scale: "x", format: "%Y-%m-%d", formatType: "utc", labelOverlap: true, labelColor: chartColors.textColor, tickColor: chartColors.textColor, domainColor: chartColors.textColor },
              { orient: "left", scale: "y", labelColor: chartColors.textColor, tickColor: chartColors.textColor, domainColor: chartColors.textColor }
            ],
            marks: [
              {
                type: "rect",
                from: { data: "heat" },
                encode: {
                  enter: {
                    x: { scale: "x", field: "interval_ts" },
                    width: { value: 6 },
                    y: { scale: "y", field: "bucket" },
                    height: { scale: "y", band: 1 },
                    fill: { signal: "datum.count === 0 ? '#e0e0e0' : scale('color', datum.count)" }
                  }
                }
              }
            ]
          };
        }

        function monthStart(dateStr) {
          const date = new Date(`${dateStr}T00:00:00Z`);
          return new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), 1));
        }

        function monthsBetween(start, end) {
          return (end.getUTCFullYear() - start.getUTCFullYear()) * 12 + (end.getUTCMonth() - start.getUTCMonth());
        }

        function bucketMonthStart(date, bucketSize) {
          const year = date.getUTCFullYear();
          const month = date.getUTCMonth();
          const bucketMonth = Math.floor(month / bucketSize) * bucketSize;
          return new Date(Date.UTC(year, bucketMonth, 1));
        }

        function buildRetentionHeatmapData(rows, rangeStart, rangeEnd) {
          const points = [];
          const cohortDomain = [];
          const seenCohorts = new Set();
          let maxMonths = 0;
          let maxIntensity = 0;
          let minIntensity = null;

          rows.forEach(row => {
            const cohortDate = monthStart(row.cohort_start);
            if (cohortDate < rangeStart || cohortDate > rangeEnd) return;
            const cohortKey = cohortDate.toISOString().slice(0, 10);
            if (!seenCohorts.has(cohortKey)) {
              cohortDomain.push(cohortKey);
              seenCohorts.add(cohortKey);
            }
            const monthsSince = Number(row.months_since);
            const retentionRate = row.cohort_size ? Number(row.active_users || 0) / Number(row.cohort_size) : 0;
            const intensity = Number(row.avg_messages_per_active_user || 0);
            maxMonths = Math.max(maxMonths, monthsSince);
            maxIntensity = Math.max(maxIntensity, intensity);
            if (intensity > 0) {
              minIntensity = minIntensity === null ? intensity : Math.min(minIntensity, intensity);
            }
            points.push({
              cohort_start: cohortKey,
              months_since: monthsSince,
              retention_rate: retentionRate,
              avg_messages_per_active_user: intensity
            });
          });

          cohortDomain.sort().reverse();

          return {
            points: points,
            cohortDomain: cohortDomain,
            maxMonths: maxMonths,
            maxIntensity: maxIntensity,
            minIntensity: minIntensity
          };
        }

        function buildRetentionHeatmapSpec(points, cohortDomain, width, height, valueField, domainMin, domainMax, colorRange, tooltipSignal, scaleType = "linear") {
          return {
            $schema: "https://vega.github.io/schema/vega/v5.json",
            width: width,
            height: height,
            padding: 10,
            autosize: { type: "fit", contains: "padding" },
            data: [{ name: "heat", values: points }],
            scales: [
              { name: "x", type: "band", domain: { data: "heat", field: "months_since", sort: true }, range: "width", padding: 0.03 },
              { name: "y", type: "band", domain: cohortDomain, range: "height", padding: 0.02 },
              { name: "color", type: scaleType, domain: [domainMin, domainMax], nice: true, range: colorRange, clamp: true }
            ],
            axes: [
              {
                orient: "bottom",
                scale: "x",
                labels: false,
                ticks: false
              },
              {
                orient: "left",
                scale: "y",
                labels: false,
                ticks: false
              }
            ],
            marks: [
              {
                type: "rect",
                from: { data: "heat" },
                encode: {
                  enter: {
                    x: { scale: "x", field: "months_since" },
                    width: { scale: "x", band: 1 },
                    y: { scale: "y", field: "cohort_start" },
                    height: { scale: "y", band: 1 },
                    fill: { signal: `datum.${valueField} === 0 ? '#e0e0e0' : scale('color', datum.${valueField})` },
                    tooltip: { signal: tooltipSignal }
                  }
                }
              }
            ]
          };
        }

        const retentionMilestoneKeys = new Map([
          [3, "retention_q1"],
          [6, "retention_q2"],
          [12, "retention_q4"],
          [18, "retention_q6"],
          [24, "retention_q8"],
          [30, "retention_q10"],
          [36, "retention_q12"],
          [48, "retention_q16"],
          [60, "retention_q20"]
        ]);

        function buildRetentionMilestoneIntervals(rows, rangeStart, rangeEnd) {
          const byCohort = new Map();
          rows.forEach(row => {
            const cohortDate = monthStart(row.cohort_start);
            if (cohortDate < rangeStart || cohortDate > rangeEnd) return;
            const key = cohortDate.toISOString().slice(0, 10);
            const horizonKey = retentionMilestoneKeys.get(Number(row.horizon_months));
            if (!horizonKey) return;
            const entry = byCohort.get(key) || { interval_start: key };
            const cohortSize = Number(row.cohort_size || 0);
            const retainedUsers = Number(row.retained_users || 0);
            entry[horizonKey] = cohortSize ? retainedUsers / cohortSize : 0;
            byCohort.set(key, entry);
          });

          return Array.from(byCohort.values())
            .map(entry => Object.assign({}, entry, {
              interval_key: entry.interval_start,
              interval_ts: Date.parse(`${entry.interval_start}T00:00:00Z`)
            }))
            .sort((a, b) => a.interval_ts - b.interval_ts);
        }

        let latestIntervals = [];
        const latestIntervalsByChart = {};
        const latestPointsByChart = {};

        function stripEditorData(spec) {
          const clone = JSON.parse(JSON.stringify(spec));
          if (Array.isArray(clone.data)) {
            clone.data = clone.data.map(entry => {
              if (entry && Object.prototype.hasOwnProperty.call(entry, "values")) {
                const stripped = Object.assign({}, entry);
                delete stripped.values;
                return stripped;
              }
              return entry;
            });
          }
          return clone;
        }

        function mergeEditorData(spec, intervals, points) {
          const clone = JSON.parse(JSON.stringify(spec));
          const existing = Array.isArray(clone.data) ? clone.data : [];
          const withoutSeries = existing.filter(entry => entry.name !== "stats" && entry.name !== "points");
          clone.data = [
            { name: "stats", values: intervals },
            { name: "points", values: points },
            ...withoutSeries
          ];
          return clone;
        }

        function renderLineChart(chartKey, intervals, embedOpts) {
          const config = chartConfigs[chartKey];
          const enabledSeries = selectedSeriesFor(chartKey);
          if (!enabledSeries.length) {
            config.el.textContent = "Select at least one series.";
            return null;
          }
          const chartWidth = chartWidthFor(config.el);
          const result = config.type === "stacked_bar"
            ? buildStackedBarSpec(intervals, chartWidth, config.height, enabledSeries)
            : (config.type === "overlay_bar"
              ? buildOverlayBarSpec(intervals, chartWidth, config.height, enabledSeries)
              : buildLineSpec(intervals, chartWidth, config.height, enabledSeries));
          if (!result || !result.spec) {
            config.el.textContent = "No data for this range yet.";
            return null;
          }
          latestPointsByChart[chartKey] = result.points;
          latestIntervalsByChart[chartKey] = intervals;
          if (config.editorEl) {
            const editorSpec = stripEditorData(result.spec);
            config.editorEl.value = JSON.stringify(editorSpec, null, 2);
          }
          return vegaEmbed(config.el, result.spec, embedOpts);
        }

        function renderCharts(data) {
          const intervals = decorateIntervals(data.intervals || []);
          if (!intervals.length || intervals.every(row => !Number.isFinite(row.interval_ts))) {
            mainEl.textContent = "No statistics available for this range yet.";
            depthEl.textContent = "No statistics available for this range yet.";
            createdDepthEl.textContent = "No statistics available for this range yet.";
            messageBreakdownEl.textContent = "No statistics available for this range yet.";
            attachmentsEl.textContent = "No statistics available for this range yet.";
            newTopicAttachmentsEl.textContent = "No statistics available for this range yet.";
            longevityEl.textContent = "No statistics available for this range yet.";
            participantLifetimeEl.textContent = "No statistics available for this range yet.";
            newParticipantRateEl.textContent = "No statistics available for this range yet.";
            participantRetentionEl.textContent = "No statistics available for this range yet.";
            retentionMilestonesEl.textContent = "No statistics available for this range yet.";
            longevityHeatmapEl.textContent = "No statistics available for this range yet.";
            retentionHeatmapEl.textContent = "No statistics available for this range yet.";
            retentionIntensityEl.textContent = "No statistics available for this range yet.";
            return;
          }

          const histogram = data.longevity_histogram || [];
          const heatmapSpec = buildLongevityHeatmapSpec(histogram, chartWidthFor(longevityHeatmapEl));
          const retentionRows = data.retention_heatmap || [];
          const retentionMilestones = data.retention_milestones || [];
          const rangeStart = monthStart(data.from);
          const rangeEnd = monthStart(data.to);
          const retentionData = buildRetentionHeatmapData(retentionRows, rangeStart, rangeEnd);
          const milestoneIntervals = buildRetentionMilestoneIntervals(retentionMilestones, rangeStart, rangeEnd);
          const rowHeight = retentionGranularityEl.value === "quarter" ? 8 : 4;
          const heatmapHeight = Math.max(240, retentionData.cohortDomain.length * rowHeight);
          const monthsLabel = retentionGranularityEl.value === "quarter" ? "q" : "mo";
          const retentionSpec = retentionData.points.length
            ? buildRetentionHeatmapSpec(
                retentionData.points,
                retentionData.cohortDomain,
                chartWidthFor(retentionHeatmapEl),
                heatmapHeight,
                "retention_rate",
                0,
                1,
                ["#d7fbff", "#08519c"],
                "timeFormat(toDate(datum.cohort_start), '%Y-%m') + ' | ' + format(datum.months_since / " + (retentionGranularityEl.value === "quarter" ? 3 : 1) + ", 'd') + ' " + monthsLabel + ": ' + format(datum.retention_rate, '.1%')",
                "linear"
              )
            : null;
          const intensitySpec = retentionData.points.length
            ? buildRetentionHeatmapSpec(
                retentionData.points,
                retentionData.cohortDomain,
                chartWidthFor(retentionIntensityEl),
                heatmapHeight,
                "avg_messages_per_active_user",
                Math.max(retentionData.minIntensity || 1, 1),
                Math.max(retentionData.maxIntensity, 1),
                ["#fff5eb", "#7f2704"],
                "timeFormat(toDate(datum.cohort_start), '%Y-%m') + ' | ' + format(datum.months_since / " + (retentionGranularityEl.value === "quarter" ? 3 : 1) + ", 'd') + ' " + monthsLabel + ": ' + format(datum.avg_messages_per_active_user, '.2f') + ' msgs/user'",
                "log"
              )
            : null;

          latestIntervals = intervals;
          const embedOpts = { actions: false, tooltip: true };
          const embeds = [];
          const mainEmbed = renderLineChart("main", intervals, embedOpts);
          if (mainEmbed) embeds.push(mainEmbed);
          const depthEmbed = renderLineChart("depth", intervals, embedOpts);
          if (depthEmbed) embeds.push(depthEmbed);
          const createdDepthEmbed = renderLineChart("created_depth", intervals, embedOpts);
          if (createdDepthEmbed) embeds.push(createdDepthEmbed);
          const messageBreakdownEmbed = renderLineChart("message_breakdown", intervals, embedOpts);
          if (messageBreakdownEmbed) embeds.push(messageBreakdownEmbed);
          const attachmentsEmbed = renderLineChart("attachments", intervals, embedOpts);
          if (attachmentsEmbed) embeds.push(attachmentsEmbed);
          const newTopicAttachmentsEmbed = renderLineChart("new_topic_attachments", intervals, embedOpts);
          if (newTopicAttachmentsEmbed) embeds.push(newTopicAttachmentsEmbed);
          const longevityEmbed = renderLineChart("longevity", intervals, embedOpts);
          if (longevityEmbed) embeds.push(longevityEmbed);
          const participantLifetimeEmbed = renderLineChart("participant_lifetime", intervals, embedOpts);
          if (participantLifetimeEmbed) embeds.push(participantLifetimeEmbed);
          const newParticipantRateEmbed = renderLineChart("new_participant_rate", intervals, embedOpts);
          if (newParticipantRateEmbed) embeds.push(newParticipantRateEmbed);
          const participantRetentionEmbed = renderLineChart("participant_retention", intervals, embedOpts);
          if (participantRetentionEmbed) embeds.push(participantRetentionEmbed);
          if (milestoneIntervals.length) {
            const retentionMilestonesEmbed = renderLineChart("retention_milestones", milestoneIntervals, embedOpts);
            if (retentionMilestonesEmbed) embeds.push(retentionMilestonesEmbed);
          } else {
            retentionMilestonesEl.textContent = "No retention milestone data available for this range yet.";
          }
          embeds.push(vegaEmbed(longevityHeatmapEl, heatmapSpec, embedOpts));
          if (retentionSpec) {
            embeds.push(vegaEmbed(retentionHeatmapEl, retentionSpec, embedOpts));
            embeds.push(vegaEmbed(retentionIntensityEl, intensitySpec, embedOpts));
          } else {
            retentionHeatmapEl.textContent = "No retention data available for this range yet.";
            retentionIntensityEl.textContent = "No retention data available for this range yet.";
          }
          Promise.all(embeds).catch(err => {
            mainEl.textContent = "Failed to render charts.";
            depthEl.textContent = "Failed to render charts.";
            createdDepthEl.textContent = "Failed to render charts.";
            messageBreakdownEl.textContent = "Failed to render charts.";
            attachmentsEl.textContent = "Failed to render charts.";
            newTopicAttachmentsEl.textContent = "Failed to render charts.";
            longevityEl.textContent = "Failed to render charts.";
            participantLifetimeEl.textContent = "Failed to render charts.";
            newParticipantRateEl.textContent = "Failed to render charts.";
            participantRetentionEl.textContent = "Failed to render charts.";
            retentionMilestonesEl.textContent = "Failed to render charts.";
            longevityHeatmapEl.textContent = "Failed to render charts.";
            retentionHeatmapEl.textContent = "Failed to render charts.";
            retentionIntensityEl.textContent = "Failed to render charts.";
          });
        }

        function load() {
          fetchData().then(renderCharts).catch(() => {
            mainEl.textContent = "Failed to load stats.";
          });
        }

        function toggleCustomRange() {
          const isCustom = rangeEl.value === "custom";
          customRangeEls.forEach(el => { el.hidden = !isCustom; });
        }

        Object.values(chartConfigs).forEach(config => {
          config.seriesInputs.forEach(input => input.addEventListener("change", () => {
            syncUrl();
            load();
          }));
        });
        collapsibleKeys.forEach(key => {
          const container = collapsibleByKey.get(key);
          if (!container) return;
          container.addEventListener("toggle", () => {
            syncUrl();
          });
        });
        granularityEl.addEventListener("change", () => {
          syncUrl();
          load();
        });
        retentionGranularityEl.addEventListener("change", () => {
          syncUrl();
          load();
        });
        retentionSegmentEl.addEventListener("change", () => {
          syncUrl();
          load();
        });
        rangeEl.addEventListener("change", () => {
          toggleCustomRange();
          if (rangeEl.value !== "custom") {
            syncUrl();
            load();
          }
        });
        applyRangeEl.addEventListener("click", () => {
          syncUrl();
          load();
        });

        Object.values(chartConfigs).forEach(config => {
          if (!config.applyEl) return;
          config.applyEl.addEventListener("click", () => {
            try {
              const spec = JSON.parse(config.editorEl.value);
              const points = latestPointsByChart[config.key] || [];
              const intervals = latestIntervalsByChart[config.key] || latestIntervals;
              const merged = mergeEditorData(spec, intervals, points);
              vegaEmbed(config.el, merged, { actions: false, tooltip: true });
            } catch (e) {
              alert("Invalid JSON spec.");
            }
          });
        });

        hydrateControlsFromUrl();
        applySeriesSwatches();
        syncUrl();
        load();
      })();
